from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.interval import IntervalTrigger
from datetime import datetime, timedelta, date
from random import shuffle
from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession
from database.models import User, Pair, Setting, Feedback
from aiogram import Bot
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
import random
from collections import defaultdict
from sqlalchemy.ext.asyncio import async_sessionmaker
from sqlalchemy import select, or_
from sqlalchemy.orm import selectinload
import asyncio
from aiogram import Dispatcher
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from apscheduler.triggers.cron import CronTrigger
from apscheduler.job import Job

scheduler = AsyncIOScheduler()

class FeedbackStates(StatesGroup):
    waiting_for_feedback_decision = State()
    waiting_for_comment_decision = State()
    writing_comment = State()

class CommentStates(StatesGroup):
    waiting_for_comment = State()

def meeting_question_kb():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚úÖ –î–∞", callback_data="meeting_yes")],
        [InlineKeyboardButton(text="‚ùå –ù–µ—Ç", callback_data="meeting_no")]
    ])

async def prompt_user_comment(user_id: int):
    # –£—Å—Ç–∞–Ω–æ–≤–∏–º FSM —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    state = FSMContext(bot.storage, bot, user_id)
    await state.set_state(CommentStates.waiting_for_comment)

    await bot.send_message(user_id, "–ü—Ä–∏–≤–µ—Ç! –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Å—Ç–∞–≤—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –æ –ø–æ—Å–ª–µ–¥–Ω–µ–π –≤—Å—Ç—Ä–µ—á–µ ‚òïÔ∏è")

async def get_users_ready_for_matching(session: AsyncSession) -> list[User]:
    """–í—ã–±–∏—Ä–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —É—á–∞—Å—Ç–∏—è –≤ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–∏ –ø–∞—Ä –ø–æ –ø—Ä–∞–≤–∏–ª–∞–º."""

    result = await session.execute(select(Setting).filter_by(key='global_interval'))
    setting = result.scalars().first()
    global_interval = setting.value if setting else 2

    result = await session.execute(select(User))
    users = result.scalars().all()
    selected_users = []
    today = datetime.utcnow().date()

    for user in users:
        # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –ø–∞—É–∑–µ
        if user.pause_until and user.pause_until > today:
            continue

        user_interval = user.pairing_interval or global_interval

        # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã—Ö, –Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º future_meeting –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
        if not user.is_active:
            if user_interval > global_interval and user.future_meeting == 0:
                user.future_meeting = 1
            continue  # –ù–µ –¥–æ–±–∞–≤–ª—è–µ–º –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã—Ö –≤ –ø–∞—Ä—ã –≤–æ–æ–±—â–µ

        # –û—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        if global_interval >= user_interval:
            user.future_meeting = 0
            selected_users.append(user)
        elif user.future_meeting == 1:
            user.future_meeting = 0
            selected_users.append(user)
        else:
            user.future_meeting = 1

    await session.commit()
    return selected_users


async def generate_unique_pairs(session, users: list[User]) -> list[Pair]:
    """–§–æ—Ä–º–∏—Ä—É–µ—Ç –ø–∞—Ä—ã, –º–∏–Ω–∏–º–∏–∑–∏—Ä—É—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π."""

    # –ó–∞–≥—Ä—É–∂–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é –≤—Å–µ—Ö –ø–∞—Ä
    result = await session.execute(select(Pair.user1_id, Pair.user2_id, Pair.user3_id))
    history = defaultdict(int)  # (min_id, max_id) -> count

    for row in result.fetchall():
        ids = [row.user1_id, row.user2_id]
        if row.user3_id:
            ids.append(row.user3_id)
        ids = sorted(ids)
        for i in range(len(ids)):
            for j in range(i + 1, len(ids)):
                history[(ids[i], ids[j])] += 1

    # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞
    random.shuffle(users)
    user_ids = [u.id for u in users]
    user_map = {u.id: u for u in users}
    used = set()
    pairs = []

    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–µ –ø–∞—Ä—ã –ø–æ —á–∏—Å–ª—É –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π
    possible_pairs = []
    for i in range(len(user_ids)):
        for j in range(i + 1, len(user_ids)):
            u1, u2 = user_ids[i], user_ids[j]
            key = tuple(sorted((u1, u2)))
            if u1 not in used and u2 not in used:
                possible_pairs.append((history[key], u1, u2))

    possible_pairs.sort()  # –æ—Ç —Å–∞–º—ã—Ö —Ä–µ–¥–∫–∏—Ö –∫ —á–∞—Å—Ç—ã–º

    for _, u1, u2 in possible_pairs:
        if u1 not in used and u2 not in used:
            used.update([u1, u2])
            pairs.append((u1, u2))

    remaining = [uid for uid in user_ids if uid not in used]
    pair_objs = []

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–∞—Ä—ã –≤ –ë–î
    for u1_id, u2_id in pairs:
        u1, u2 = user_map[u1_id], user_map[u2_id]
        pair = Pair(
            user1_id=u1.id, user2_id=u2.id,
            user1_username=u1.username,
            user2_username=u2.username,
            paired_at=datetime.utcnow()
        )
        u1.last_paired_at = datetime.utcnow()
        u2.last_paired_at = datetime.utcnow()
        session.add(pair)
        pair_objs.append(pair)

    if remaining:
        odd = user_map[remaining[0]]
        odd.last_paired_at = datetime.utcnow()
        if pair_objs:
            last_pair = pair_objs[-1]
            last_pair.user3_id = odd.id
            last_pair.user3_username = odd.username
            session.add(last_pair)
        else:
            print(f"‚ö†Ô∏è –û–¥–∏–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Å—Ç–∞–ª—Å—è –±–µ–∑ –ø–∞—Ä—ã: {odd.username or odd.id}")

    return pair_objs


async def notify_users_about_pairs(session: AsyncSession, pairs: list[Pair], bot: Bot):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–∞–º –ø–∞—Ä —á–µ—Ä–µ–∑ Telegram, –∏—Å–ø–æ–ª—å–∑—É—è HTML-—Å—Å—ã–ª–∫–∏ —Å tg://user?id."""
    for pair in pairs:
        user_ids = [pair.user1_id, pair.user2_id]
        if pair.user3_id:
            user_ids.append(pair.user3_id)

        # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –≤—Å–µ—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –ø–∞—Ä—ã
        result = await session.execute(
            select(User.id, User.telegram_id, User.first_name, User.last_name).where(User.id.in_(user_ids))
        )
        user_data = {
            row.id: {
                "telegram_id": row.telegram_id,
                "first_name": row.first_name or "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å",
                "last_name": row.last_name,
            }
            for row in result.fetchall()
        }

        for user_id in user_ids:
            user_info = user_data.get(user_id)
            if not user_info or not user_info["telegram_id"]:
                print(f"‚ùó –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ telegram_id –¥–ª—è user_id={user_id}")
                continue

            # –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Å—ã–ª–∫–∏ –Ω–∞ –ø–∞—Ä—Ç–Ω—ë—Ä–æ–≤
            partner_links = []
            for partner_id in user_ids:
                if partner_id == user_id:
                    continue
                partner = user_data.get(partner_id)
                if partner and partner["telegram_id"]:
                    name = f'{partner["first_name"]} {partner["last_name"]}'.strip()
                    link = f'<a href="tg://user?id={partner["telegram_id"]}">{name}</a>'
                    partner_links.append(link)
                else:
                    partner_links.append("–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å")

            partners_str = ", ".join(partner_links)

            message = (
                f"üë• –í–∞—à–∞ –ø–∞—Ä–∞ –Ω–∞ —ç—Ç—É –Ω–µ–¥–µ–ª—é:\n"
                f"{partners_str}\n\n"
                f"–°–≤—è–∂–∏—Ç–µ—Å—å –¥—Ä—É–≥ —Å –¥—Ä—É–≥–æ–º –∏ –¥–æ–≥–æ–≤–æ—Ä–∏—Ç–µ—Å—å –æ –≤—Å—Ç—Ä–µ—á–µ!"
            )

            try:
                await bot.send_message(chat_id=user_info["telegram_id"], text=message, parse_mode="HTML")
            except Exception as e:
                print(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è user_id={user_id}: {e}")



async def auto_pairing(session_maker, bot: Bot):
    async with session_maker() as session:
        users = await get_users_ready_for_matching(session)
        if len(users) < 2:
            print("‚ùó –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è –ø–∞—Ä.")
            return

        # üí° –ù–æ–≤—ã–π —Å–ø–æ—Å–æ–± —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è –ø–∞—Ä
        pairs = await generate_unique_pairs(session, users)

        await session.commit()
        print(f"‚úÖ –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–æ {len(pairs)} –ø–∞—Ä.")

        await notify_users_about_pairs(session, pairs, bot)

async def save_comment(telegram_id: int, comment_text: str, session_maker: async_sessionmaker) -> str:
    async with session_maker() as session:
        # –ü–æ–ª—É—á–∞–µ–º user –ø–æ telegram_id
        result_user = await session.execute(
            select(User).where(User.telegram_id == telegram_id)
        )
        user = result_user.scalar()
        if user is None:
            return f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å telegram_id {telegram_id} –Ω–µ –Ω–∞–π–¥–µ–Ω"

        user_id = user.id

        # –ò—â–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é –ø–∞—Ä—É, –≥–¥–µ –æ–Ω –µ—Å—Ç—å
        result_pair = await session.execute(
            select(Pair)
            .where(or_(Pair.user1_id == user_id, Pair.user2_id == user_id, Pair.user3_id == user_id))
            .order_by(Pair.paired_at.desc())
        )
        pair = result_pair.scalars().first()

        if not pair:
            return "–û—à–∏–±–∫–∞: –≤—ã –µ—â—ë –Ω–µ —É—á–∞—Å—Ç–≤—É–µ—Ç–µ –≤ –ø–∞—Ä–µ ü§∑"

        # –¢—É—Ç —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π
        pair_id = pair.id

        result_feedback = await session.execute(
            select(Feedback).where(Feedback.user_id == user_id, Feedback.pair_id == pair_id)
        )
        feedback = result_feedback.scalar()

        if feedback:
            feedback.comment = comment_text
            feedback.submitted_at = datetime.utcnow()
            feedback.did_meet = True
            status_msg = "–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –æ–±–Ω–æ–≤–ª—ë–Ω ‚úÖ"
        else:
            new_feedback = Feedback(
                pair_id=pair_id,
                user_id=user_id,
                comment=comment_text,
                did_meet=True,
                submitted_at=datetime.utcnow()
            )
            session.add(new_feedback)
            status_msg = "–°–ø–∞—Å–∏–±–æ –∑–∞ –≤–∞—à –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π ‚úÖ"

        await session.commit()
        return status_msg


async def start_feedback_prompt(bot: Bot, telegram_id: int, dispatcher: Dispatcher):
    fsm_context = dispatcher.fsm.get_context(user_id=telegram_id, chat_id=telegram_id, bot=bot)

    # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    state = await fsm_context.get_state()

    await bot.send_message(
        telegram_id,
        "–ü—Ä–∏–≤–µ—Ç! –ü—Ä–æ—à–ª–∞ –ª–∏ –≤—Å—Ç—Ä–µ—á–∞?",
        reply_markup=meeting_question_kb()  # –£–±–µ–¥–∏—Å—å, —á—Ç–æ —É —Ç–µ–±—è –µ—Å—Ç—å —Ñ—É–Ω–∫—Ü–∏—è meeting_question_kb()
    )

    await fsm_context.set_state(FeedbackStates.waiting_for_feedback_decision)

def show_next_runs(scheduler: AsyncIOScheduler):
    print("üîî –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –±–ª–∏–∂–∞–π—à–∏—Ö –∑–∞–ø—É—Å–∫–æ–≤ –∑–∞–¥–∞—á:")

    for job in scheduler.get_jobs():
        next_run = job.next_run_time
        print(f"üõ† –ó–∞–¥–∞—á–∞ '{job.id}' –∑–∞–ø—É—Å—Ç–∏—Ç—Å—è –≤: {next_run.strftime('%Y-%m-%d %H:%M:%S') if next_run else '–Ω–µ—Ç –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞'}")

async def schedule_feedback_jobs(bot: Bot, session_maker, dispatcher: Dispatcher):
    async def setup_jobs():
        async with session_maker() as session:
            setting_result = await session.execute(
                select(Setting.value).where(Setting.key == "global_interval")
            )
            setting_value = setting_result.scalar()
            interval_weeks = setting_value if setting_value is not None else 2
            interval_day = interval_weeks * 7 -3
            users_result = await session.execute(select(User.telegram_id).where(User.is_active == True))
            telegram_ids = users_result.scalars().all()

            for telegram_id in telegram_ids:
                scheduler.add_job(
                    start_feedback_prompt,
                    trigger=IntervalTrigger(days=interval_day),
                    args=[bot, telegram_id, dispatcher],
                    id=f"feedback_{telegram_id}",
                    replace_existing=True,
                )

        scheduler.add_job(
            auto_pairing,
            trigger=IntervalTrigger(weeks=interval_weeks),
            args=[session_maker, bot],
            id="auto_pairing_weekly"
        )

    # ‚¨á‚¨á‚¨á –ñ–¥–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è setup_jobs –ø–µ—Ä–µ–¥ —Å—Ç–∞—Ä—Ç–æ–º –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞
    await setup_jobs()

    # –¢–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ –∑–∞–ø—É—Å–∫–∞—Ç—å –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –∏ –ø–µ—á–∞—Ç–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ
    if not scheduler.running:
        scheduler.start()

    show_next_runs(scheduler)


